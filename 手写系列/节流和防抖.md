# 节流和防抖

使用 JavaScript 进行开发时，都会使用到事件，有一些事件我们只想触发一次，但却频繁触发，以下是列出了一些频繁的事件触发：

- `window` 的 `resize`、`scroll`
- `mousedown`、`mousemove`
- `keyup`、`keydown`
- ...

如果处理的是复杂的逻辑，一次性触发多次可能会造成页面卡顿。

有两种方式可以限制事件的频繁触发：**节流（throttle）和防抖（debounce）**。

## 防抖

> 无论触发多少次事件，都以最新事件的时间为准。

只需要在每次触发事件时都取消之前的延时调用方法：

```js
function debounce(fn, wait) {
  let timer
  return function () {
    const args = [...arguments]
    if (timer) clearTimeout(timeout)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, wait)
  }
}
```

### 示例

查看是否触底，常用于触底加载更多数据：

```js
const isAtBottom = function () {
  console.log(
    document.documentElement.clientHeight + window.scrollY >=
      document.documentElement.scrollHeight
  )
}

document.addEventListener('scroll', debounce(isAtBottom, 1000))
```

> [查看效果](https://codepen.io/lio-zero/pen/wvqQxbb)

## 节流

> 如果持续触发事件，每隔一段时间，只执行一次事件。

只需要在每次触发事件时，判断当前是否有等待执行的延时函数。

有两种实现方式：时间戳和定时器。

### 时间戳

```js
function throttle(fn, wait) {
  let previous = 0

  return function () {
    const now = +new Date()
    const args = arguments
    if (now - previous > wait) {
      fn.apply(this, args)
      previous = now
    }
  }
}
```

### 定时器

```js
function throttle(fn, wait) {
  let timer

  return function () {
    const context = this
    const args = arguments
    if (timer) return
    timer = setTimeout(() => {
      timer = null
      fn.apply(context, args)
    }, wait)
  }
}
```

## 更多资料

- [JavaScript 专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/22)
- [JavaScript 专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)
- [介绍防抖节流原理、区别以及应用，并用 JavaScript 进行实现](https://github.com/lgwebdream/FE-Interview/issues/15)
